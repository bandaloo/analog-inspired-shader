<!DOCTYPE html>
<html lang="en">
  <head>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <canvas id="gl"></canvas>
    <div>
      <input type="range" min="0.0" max="255.0" value="255.0" id="red1" />
      <input type="range" min="0.0" max="255.0" value="0.0" id="green1" />
      <input type="range" min="0.0" max="255.0" value="0.0" id="blue1" />
    </div>
  </body>
  <!-- vertex shader, as simple as possible -->
  <script id="vertex" type="x-shader/x-vertex">
    attribute vec2 a_position;

    void main() {
      gl_Position = vec4( a_position, 0., 1. );
    }
  </script>

  <!-- fragment shader -->
  <script id="fragment" type="x-shader/x-fragment">
    #ifdef GL_ES
    precision mediump float;
    #endif

    uniform mediump float u_time;
    uniform mediump vec2 u_resolution;

    uniform mediump vec3 u_color1;
    uniform mediump vec3 u_color2;

    const float pi = 3.14159265358979323846;

    /*
    Features:
    - Sin oscillators (done)
    - Square wave oscillator (done)
    - RGB controls (done)
    - Noise generator (done)
    - Triangle oscillator
    - Color inversion (done)
    - Luma inversion (done)
    - Luma keying (done)
    */

    float sinOscillator(float c, float freq) {
      return (1.0 + sin(pi / 2.0 + c * freq * pi)) / 2.0;
    }

    float squareOscillator(float c, float freq) {
      return step(mod(c * freq, 1.0), 0.5);
    }

    // random function is from Book of Shaders
    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
    }

    void main() {
      // TODO make uniform
      const float brightness = 1.0;
      vec2 p = gl_FragCoord.xy / u_resolution.xy;

      vec3 color1 = u_color1;
      vec3 color2 = vec3(0.0, 0.0, 1.0);

      float hFrequency = 2.0;
      float vFrequency = 2.0;

      float sinFreqScalar = 4.0;
      float squareFreqScalar = 1.0;

      // horizontal sin waves used for luma
      float hSinAmplitude = 1.0;
      float hSin = hSinAmplitude * sinOscillator(p.x, hFrequency * sinFreqScalar);

      // vertical sin waves used for chroma keying
      float vSinAmplitude = 1.0;
      float vSin = vSinAmplitude * sinOscillator(p.y, vFrequency * sinFreqScalar);

      // horizontal square wave used for color inversion
      float hSquareAmplitude = 1.0;
      float hSquare = hSquareAmplitude * squareOscillator(p.x, hFrequency * squareFreqScalar);

      // vertical square wave used for luma inversion
      float vSquareAmplitude = 1.0;
      float vSquare = vSquareAmplitude * squareOscillator(p.y, vFrequency * squareFreqScalar);

      // luma is used to mix between colors
      float luma = vSquare - sign(vSquare - 0.5) * brightness * hSin * vSin;
      vec3 color = hSquare - sign(hSquare - 0.5) * mix(color1, color2, luma);

      //vec3 color = mix(vec3(luma), color1, vSin);
      //color = mix(vec3(color), color2, hSin);

      // the mod in random is because the randomizer does strange things with a large time
      gl_FragColor = vec4(random(p + mod(u_time, 1.0)) * color, 1.0);
    }
  </script>

  <script type="text/javascript">
    // "global" variables
    let gl, uTime, uColor1, uColor2;

    window.onload = function() {
      const canvas = document.getElementById("gl");
      gl = canvas.getContext("webgl");
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      // define drawing area of canvas. bottom corner, width / height
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

      // create a buffer object to store vertices
      const buffer = gl.createBuffer();

      // point buffer at graphic context's ARRAY_BUFFER
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

      const triangles = new Float32Array([
        -1,
        -1,
        1,
        -1,
        -1,
        1,
        -1,
        1,
        1,
        -1,
        1,
        1
      ]);

      // initialize memory for buffer and populate it. Give
      // open gl hint contents will not change dynamically.
      gl.bufferData(gl.ARRAY_BUFFER, triangles, gl.STATIC_DRAW);

      // create vertex shader
      let shaderScript = document.getElementById("vertex");
      let shaderSource = shaderScript.text;
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, shaderSource);
      gl.compileShader(vertexShader);

      // create fragment shader
      shaderScript = document.getElementById("fragment");
      shaderSource = shaderScript.text;
      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, shaderSource);
      gl.compileShader(fragmentShader);

      // create shader program
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      gl.useProgram(program);

      /* ALL ATTRIBUTE/UNIFORM INITIALIZATION MUST COME AFTER 
      CREATING/LINKING/USING THE SHADER PROGAM */

      // find a pointer to the uniform "time" in our fragment shader
      uTime = gl.getUniformLocation(program, "u_time");
      const uRes = gl.getUniformLocation(program, "u_resolution");
      gl.uniform2f(uRes, window.innerWidth, window.innerHeight);

      // find a pointer to the uniform for the first color
      uColor1 = gl.getUniformLocation(program, "u_color1");

      // get position attribute location in shader
      const position = gl.getAttribLocation(program, "a_position");
      // enable the attribute
      gl.enableVertexAttribArray(position);
      // this will point to the vertices in the last bound array buffer.
      // In this example, we only use one array buffer, where we're storing
      // our vertices
      gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

      render();
    };

    // keep track of time via incremental frame counter
    let time = 0;
    function render() {
      // schedules render to be called the next time the video card requests
      // a frame of video
      window.requestAnimationFrame(render);

      // update time on CPU and GPU
      time++;
      gl.uniform1f(uTime, time);

      // update the color
      const sliderMax = 255;
      const red1 = parseFloat(document.getElementById("red1").value);
      const green1 = parseFloat(document.getElementById("green1").value);
      const blue1 = parseFloat(document.getElementById("blue1").value);
      gl.uniform3f(
        uColor1,
        red1 / sliderMax,
        green1 / sliderMax,
        blue1 / sliderMax
      );

      // draw triangles using the array buffer from index 0 to 6 (6 is count)
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }
  </script>
</html>
